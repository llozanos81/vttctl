#!/usr/bin/env bash

function stop() {
    docker-compose -p $PROD_PROJECT -f docker/docker-compose.yml stop
    docker-compose -p $DEV_PROJECT -f docker/docker-compose-dev.yml stop
}

function getLogs() {
    docker-compose -p $PROD_PROJECT -f docker/docker-compose.yml logs
}

function liveLogs() {
    docker-compose -p $PROD_PROJECT -f docker/docker-compose.yml logs -f
}

function getVersion() {
    RESPONSE=/tmp/.response.txt
    rm -rf $RESPONSE
    status=$(curl -s -w %{http_code} http://localhost:${NGINX_PROD_PORT}/api/status -H "Accept: application/json" -o $RESPONSE)
    if [ $status == 200 ]; then
        cat $RESPONSE
    else
        echo "{ 'active': 'false' }"
    fi
}

function appReload() {
    CONT_NAME=$(docker container ls -a | grep vtt | grep app | grep prod | awk '{print $1}')
    docker exec -d $CONT_NAME pm2 restart VTT
}

function prodBackup()  {
    METADATA="backups/FoundryVTT/metadata.json"
    CONT_NAME=$(docker container ls -a | grep vtt | grep app | grep prod | awk '{print $1}')
    json=$(getVersion)
    if jq -e . >/dev/null 2>&1 <<<"$json"; then
        PROD_VER=$(echo $json | jq -r .version)
        if [[ -n $PROD_VER ]]; then
            DATESTAMP=$(date +"%Y%m%d")
            BACKUP_FILE=foundry_userdata_${PROD_VER}-${DATESTAMP}.tar

            docker run \
                --rm \
                -v foundryvtt_prod_UserData:/source/ \
                -v $(pwd)/backups/FoundryVTT/:/backup \
                busybox \
                ash -c " \
                tar -cvf /backup/$BACKUP_FILE \
                    -C / /source \
                ; chown $UID:$GID /backup/$BACKUP_FILE" >/dev/null 2>&1 &

            BACKPID=$!

            i=1
            sp="/-\|"
            echo -n ' '
            while [ -d /proc/$BACKPID ]; do
                printf "\r%c" "${sp:0:1}"
                sp="${sp:1}${sp:0:1}"
                sleep 0.05
            done

            DATE_FILE=$(stat --format="%y" "backups/FoundryVTT/$BACKUP_FILE" | awk {'print $1'})
            new_object="{\"$DATE_FILE\": {\"Version\": \"${PROD_VER}\", \"File\": \"${BACKUP_FILE}\"}}"
            python3 -c "import json; \
                        obj = $new_object; \
                        filename = '${METADATA}'; \
                        data = json.load(open(filename)) \
                        if filename else []; \
                        data.append(obj) \
                        if obj not in data else None; \
                        json.dump(data, open(filename, 'w'), indent=2)"
            printf "\r   - %s backup file created\n" "$BACKUP_FILE"
            echo "   - Done!."
        fi
    fi
}

function prodLatestRestore() {
    REST_FILE=$(ls -t backups/*tar | head -1)
    FILE_NAME=$(basename ${REST_FILE})
    
    docker run \
                --rm \
                -v foundryvtt_prod_UserData:/source/ \
                -v $(pwd)/backups/FoundryVTT/:/backup \
                busybox \
                tar -xvf /backup/${FILE_NAME} -C /source/

}

function devLatestRestore() {
    REST_FILE=$(ls -t backups/*tar | head -1)
    FILE_NAME=$(basename ${REST_FILE})
    CONT_NAME=$(docker container ls -a | grep vtt | grep app | grep dev | awk '{print $1}')
    
    docker run \
                --rm \
                --volumes-from $CONT_NAME \
                -v $(pwd)/backups/FoundryVTT/:/backup \
                busybox \
                tar -xvf /backup/${FILE_NAME} -C /

}

function fixOnwer() {
    CONT_NAME=$(docker container ls -a | grep vtt | grep app | grep prod | awk '{print $1}')
    docker run --rm --volumes-from ${CONT_NAME} busybox chown 3000:3000 -R /home/foundry/userdata
}

function getIPaddr() {
    gateway_ip=$(ip route | awk '/default/ {print $3}' | sort -u)
    interface=$(ip route get $gateway_ip | awk '/dev/ {print $3}')
    ip_address=$(ip -o -4 addr show dev $interface | awk '{print $4}' | awk -F '/' '{print $1}')
    echo $ip_address
}

function getReleases() {
    url="https://foundryvtt.com/releases/"
    html_content=$(curl -s "$url")

    # Set custom record separator to </li>
    # Extract <li> elements containing the stable release
    stable_li_elements=$(awk -v RS='</li>' '/<span class="release-tag stable">Stable<\/span>/{print $0 "</li>"}' <<< "$html_content")

    # Extract the release versions from stable <li> elements
    release_versions=$(echo "$stable_li_elements" | grep -oP '(?<=<a href="/releases/)(9|[1-9][0-9]+)\.\d+')
    
    file_path="FoundryVTT/foundry_releases.json"
    max_age_days=1
    file_age=$(($(date +%s) - $(date -r "$file_path" +%s)))
 
    versions=()
    current_version=""

    while IFS= read -r line; do
    version=$(echo "$line" | awk -F '.' '{print $1}')
    build=$(echo "$line" | awk -F '.' '{print $2}')

    if [[ "$version" != "$current_version" ]]; then
        versions+=("{\"version\":\"$version\",\"build\":[{\"number\":$build,\"latest\":false}]}")
        current_version=$version
    else
        index=$((${#versions[@]} - 1))
        versions[$index]=$(jq ".build += [{\"number\":$build,\"latest\":false}]" <<< "${versions[$index]}")
        last_index=$(($index - 1))
        versions[$last_index]=$(jq ".build[-1].latest=true" <<< "${versions[$last_index]}")
    fi
    done <<< "$output"

    last_index=$((${#versions[@]} - 1))
    versions[$last_index]=$(jq ".build[-1].latest=true" <<< "${versions[$last_index]}")

    json=$(jq -n "{\"versions\":[$(IFS=,; echo "${versions[*]}")]}" 2>/dev/null)

    echo "$json" > "$file_path"

}